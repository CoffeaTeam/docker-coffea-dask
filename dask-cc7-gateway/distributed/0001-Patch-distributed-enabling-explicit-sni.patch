diff --git a/distributed/cli/dask_worker.py b/distributed/cli/dask_worker.py
index 7fe8e8a..d6c2a20 100755
--- a/distributed/cli/dask_worker.py
+++ b/distributed/cli/dask_worker.py
@@ -253,6 +253,12 @@ pem_file_option_type = click.Path(exists=True, resolve_path=True)
     help="Module that should be loaded by each nanny "
     'like "foo.bar" or "/path/to/foo.py"',
 )
+@click.option(
+    "--scheduler-sni",
+    type=str,
+    default=None,
+    help="Scheduler SNI (if different from scheduler hostname)",
+)
 @click.version_option()
 def main(  # type: ignore[no-untyped-def]
     scheduler,
diff --git a/distributed/comm/tcp.py b/distributed/comm/tcp.py
index f3f0ba1..8ff4bfe 100644
--- a/distributed/comm/tcp.py
+++ b/distributed/comm/tcp.py
@@ -488,9 +488,17 @@ class BaseTCPConnector(Connector, RequireEncryptionMixin):
         kwargs = self._get_connect_args(**connection_args)
 
         try:
-            stream = await self.client.connect(
-                ip, port, max_buffer_size=MAX_BUFFER_SIZE, **kwargs
-            )
+            # server_hostname option (for SNI) only works with tornado.iostream.IOStream
+            if "server_hostname" in kwargs:
+                stream = await self.client.connect(
+                    ip, port, max_buffer_size=MAX_BUFFER_SIZE
+                )
+                stream = await stream.start_tls(False, **kwargs)
+            else:
+                stream = await self.client.connect(
+                    ip, port, max_buffer_size=MAX_BUFFER_SIZE, **kwargs
+                )
+
             # Under certain circumstances tornado will have a closed connnection with an
             # error and not raise a StreamClosedError.
             #
@@ -532,8 +540,10 @@ class TLSConnector(BaseTCPConnector):
     encrypted = True
 
     def _get_connect_args(self, **connection_args):
-        ctx = _expect_tls_context(connection_args)
-        return {"ssl_options": ctx}
+        tls_args = {"ssl_options": _expect_tls_context(connection_args)}
+        if connection_args.get("server_hostname"):
+            tls_args["server_hostname"] = connection_args["server_hostname"]
+        return tls_args
 
 
 class BaseTCPListener(Listener, RequireEncryptionMixin):
diff --git a/distributed/comm/ws.py b/distributed/comm/ws.py
index 8e4aebf..a72a3a8 100644
--- a/distributed/comm/ws.py
+++ b/distributed/comm/ws.py
@@ -441,8 +441,18 @@ class WSSConnector(WSConnector):
     comm_class = WSS
 
     def _get_connect_args(self, **connection_args):
-        ctx = connection_args.get("ssl_context")
-        return {"ssl_options": ctx, **connection_args.get("extra_conn_args", {})}
+        wss_args = {
+            "ssl_options": connection_args.get("ssl_context"),
+            **connection_args.get("extra_conn_args", {}),
+        }
+
+        if connection_args.get("server_hostname"):
+            wss_args["headers"] = {
+                **wss_args.get("headers", {}),
+                **{"Host": connection_args["server_hostname"]},
+            }
+
+        return wss_args
 
 
 class WSBackend(BaseTCPBackend):
diff --git a/distributed/worker.py b/distributed/worker.py
index 9f281a0..e779378 100644
--- a/distributed/worker.py
+++ b/distributed/worker.py
@@ -496,6 +496,7 @@ class Worker(BaseWorker, ServerNode):
         memory_pause_fraction: float | Literal[False] | None = None,
         ###################################
         # Parameters to Server
+        scheduler_sni: str | None = None,
         **kwargs,
     ):
         if reconnect is not None:
@@ -640,6 +641,8 @@ class Worker(BaseWorker, ServerNode):
         self.connection_args = self.security.get_connection_args("worker")
 
         self.loop = self.io_loop = IOLoop.current()
+        if scheduler_sni:
+            self.connection_args["server_hostname"] = scheduler_sni
 
         # Common executors always available
         self.executors = {
-- 
1.8.3.1
